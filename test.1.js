[
  "constructor: function NumberExpressionContext(parser, ctx) {\n\tSingleExpressionContext.call(this, parser);\n    SingleExpressionContext.prototype.copyFrom.call(this, ctx);\n    return this;\n}",
  "Number: function() {\n    return this.getToken(ECMAScriptParser.Number, 0);\n}",
  "arguments: function() {\n    return this.getTypedRuleContext(ArgumentsContext,0);\n}",
  "enterRule: function(listener) {\n    if(listener instanceof ECMAScriptListener ) {\n        listener.enterNumberExpression(this);\n\t}\n}",
  "exitRule: function(listener) {\n    if(listener instanceof ECMAScriptListener ) {\n        listener.exitNumberExpression(this);\n\t}\n}",
  "accept: function(visitor) {\n    if ( visitor instanceof ECMAScriptVisitor ) {\n        return visitor.visitNumberExpression(this);\n    } else {\n        return visitor.visitChildren(this);\n    }\n}",
  "copyFrom: function(ctx) {\n    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);\n}",
  "addChild: function(child) {\n    if (this.children === null) {\n        this.children = [];\n    }\n    this.children.push(child);\n    return child;\n}",
  "removeLastChild: function() {\n    if (this.children !== null) {\n        this.children.pop();\n    }\n}",
  "addTokenNode: function(token) {\n    var node = new TerminalNodeImpl(token);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n}",
  "addErrorNode: function(badToken) {\n    var node = new ErrorNodeImpl(badToken);\n    this.addChild(node);\n    node.parentCtx = this;\n    return node;\n}",
  "getChild: function(i, type) {\n\ttype = type || null;\n\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\treturn null;\n\t}\n\tif (type === null) {\n\t\treturn this.children[i];\n\t} else {\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif(child instanceof type) {\n\t\t\t\tif(i===0) {\n\t\t\t\t\treturn child;\n\t\t\t\t} else {\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n    }\n}",
  "getToken: function(ttype, i) {\n\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\treturn null;\n\t}\n\tfor(var j=0; j<this.children.length; j++) {\n\t\tvar child = this.children[j];\n\t\tif (child instanceof TerminalNode) {\n\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\tif(i===0) {\n\t\t\t\t\treturn child;\n\t\t\t\t} else {\n\t\t\t\t\ti -= 1;\n\t\t\t\t}\n\t\t\t}\n        }\n\t}\n    return null;\n}",
  "getTokens: function(ttype ) {\n    if (this.children=== null) {\n        return [];\n    } else {\n\t\tvar tokens = [];\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\ttokens.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n    }\n}",
  "getTypedRuleContext: function(ctxType, i) {\n    return this.getChild(i, ctxType);\n}",
  "getTypedRuleContexts: function(ctxType) {\n    if (this.children=== null) {\n        return [];\n    } else {\n\t\tvar contexts = [];\n\t\tfor(var j=0; j<this.children.length; j++) {\n\t\t\tvar child = this.children[j];\n\t\t\tif (child instanceof ctxType) {\n\t\t\t\tcontexts.push(child);\n\t\t\t}\n\t\t}\n\t\treturn contexts;\n\t}\n}",
  "getChildCount: function() {\n\tif (this.children=== null) {\n\t\treturn 0;\n\t} else {\n\t\treturn this.children.length;\n\t}\n}",
  "getSourceInterval: function() {\n    if( this.start === null || this.stop === null) {\n        return INVALID_INTERVAL;\n    } else {\n        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n    }\n}",
  "depth: function() {\n\tvar n = 0;\n\tvar p = this;\n\twhile (p !== null) {\n\t\tp = p.parentCtx;\n\t\tn += 1;\n\t}\n\treturn n;\n}",
  "isEmpty: function() {\n\treturn this.invokingState === -1;\n}",
  "getRuleContext: function() {\n\treturn this;\n}",
  "getPayload: function() {\n\treturn this;\n}",
  'getText: function() {\n\tif (this.getChildCount() === 0) {\n\t\treturn "";\n\t} else {\n\t\treturn this.children.map(function(child) {\n\t\t\treturn child.getText();\n\t\t}).join("");\n\t}\n}',
  "getAltNumber: function() { return INVALID_ALT_NUMBER; }",
  "setAltNumber: function(altNumber) { }",
  "toStringTree: function(ruleNames, recog) {\n\treturn Trees.toStringTree(this, ruleNames, recog);\n}",
  'toString: function(ruleNames, stop) {\n\truleNames = ruleNames || null;\n\tstop = stop || null;\n\tvar p = this;\n\tvar s = "[";\n\twhile (p !== null && p !== stop) {\n\t\tif (ruleNames === null) {\n\t\t\tif (!p.isEmpty()) {\n\t\t\t\ts += p.invokingState;\n\t\t\t}\n\t\t} else {\n\t\t\tvar ri = p.ruleIndex;\n\t\t\tvar ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t: "" + ri;\n\t\t\ts += ruleName;\n\t\t}\n\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\ts += " ";\n\t\t}\n\t\tp = p.parentCtx;\n\t}\n\ts += "]";\n\treturn s;\n}'
];
