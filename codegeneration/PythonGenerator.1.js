const path = require("path");
const ECMAScriptVisitor = require("../lib/ECMAScriptVisitor").ECMAScriptVisitor;

const { SemanticArgumentCountMismatchError } = require(path.resolve(
  "error",
  "helper"
));

/**
 * This Visitor walks the tree generated by parsers and produces Python code
 *
 * @returns {object}
 */
class Visitor extends ECMAScriptVisitor {
  /**
   * Entry point of tree visiting
   *
   * @param {object} ctx
   * @returns {string}
   */
  start(ctx) {
    return this.visitExpressionSequence(ctx);
  }

  /**
   * Visits children of current node
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitChildren(ctx) {
    let code = "";

    for (let i = 0; i < ctx.getChildCount(); i++) {
      console.log(">>>code", this.visit(ctx.getChild(i)));
      code += this.visit(ctx.getChild(i));
      if (code === "function") code += " ";
    }

    return code.trim();
  }

  /**
   * Visits a leaf node and returns a string
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitTerminal(ctx) {
    return ctx.getText();
  }

  /**
   * Visits Property Expression Assignment
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitPropertyExpressionAssignment(ctx) {
    // console.log(ctx.getText()); // Return the text of all tokens in the stream
    // console.log(ctx.getChildCount()); // How many children are there? If there is none, then this node represents a leaf node
    // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
    // console.log(ctx.getChild(1).getText()); // ':'
    // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

    const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
    const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

    return `'${key}': ${value}`;
  }

  // /**
  //  * Visits If Statement
  //  *
  //  * @param {object} ctx
  //  * @returns {string}
  //  */
  // visitIfStatement(ctx) {
  //   console.log(ctx.getText(), "visitFunctionDeclaration -> getText"); // Return the text of all tokens in the stream
  //   console.log(
  //     ctx.getChildCount(),
  //     "visitFunctionDeclaration -> getChildCount"
  //   );

  //   // console.log(ctx.getText()); // Return the text of all tokens in the stream
  //   // console.log(ctx.getChildCount()); // How many children are there? If there is none, then this node represents a leaf node
  //   // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
  //   // console.log(ctx.getChild(1).getText()); // ':'
  //   // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

  //   // const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
  //   // const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

  //   // return ``;
  // }

  /**
   * Visits Function Declaration
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitFunctionExpression(ctx) {
    // console.log(ctx.getText(), "visitFunctionDeclaration -> getText"); // Return the text of all tokens in the stream
    // console.log(
    // ctx.getChildCount(),
    // "visitFunctionDeclaration -> getChildCount"
    // ); // How many children are there? If there is none, then this node represents a leaf node
    // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
    // console.log(ctx.getChild(1).getText()); // ':'
    // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

    // const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
    // const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)
    console.log(ctx.getChild(0).getText(), "child 0");
    console.log(ctx.getChild(1).getText(), "child 1");
    console.log(ctx.getChild(2).getText(), "child 2");
    console.log(ctx.getChild(3).getText(), "child 3");
    console.log(ctx.getChild(4).getText(), "child 4");
    console.log(ctx.getChild(5).getText(), "child 5");
    console.log(ctx.getChild(6).getText(), "child 6");
    const functionName = ctx.getChild(1).getText();

    return `def ${functionName}(${this.visitFormalParameterList(
      ctx
    )}):\n\t${this.visitFunctionBody(ctx)}`;
  }
  /**
   * Visits Function Declaration
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitFunctionDeclaration(ctx) {
    console.log(ctx.getText(), "visitFunctionDeclaration -> getText"); // Return the text of all tokens in the stream
    console.log(
      ctx.getChildCount(),
      "visitFunctionDeclaration -> getChildCount"
    ); // How many children are there? If there is none, then this node represents a leaf node
    // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
    // console.log(ctx.getChild(1).getText()); // ':'
    // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

    // const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
    // const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

    return `declaration`;
  }
  /**
   * Visits Formal Parameter List
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitFormalParameterList(ctx) {
    console.log(ctx.getText(), "visitFormalParameterList -> getText"); // Return the text of all tokens in the stream
    console.log(
      ctx.getChildCount(),
      "visitFormalParameterList -> getChildCount"
    ); // How many children are there? If there is none, then this node represents a leaf node
    // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
    // console.log(ctx.getChild(1).getText()); // ':'
    // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

    // const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
    // const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

    return `params`;
  }

  /**
   * Visits Function Body
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitFunctionBody(ctx) {
    console.log(ctx.getText(), "visitFunctionBody -> getText"); // Return the text of all tokens in the stream
    console.log(ctx.getChildCount(), "visitFunctionBody -> getChildCount"); // How many children are there? If there is none, then this node represents a leaf node
    // console.log(ctx.getChild(0).getText()); // console.log(ctx.propertyName().getText()) Property 'x'
    // console.log(ctx.getChild(1).getText()); // ':'
    // console.log(ctx.getChild(2).getText()); // console.log(ctx.singleExpression().getText()) Value '1'

    // const key = this.visit(ctx.propertyName()); // ctx.getChild(0)
    // const value = this.visit(ctx.singleExpression()); // ctx.getChild(2)

    return `body`;
  }

  /**
   * Because Python doesn't need `New`, we can skip the first child
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitNewExpression(ctx) {
    return this.visit(ctx.singleExpression());
  }

  /**
   * Visits `Number` Keyword
   *
   * @param {object} ctx
   * @returns {string}
   */
  visitNumberExpression(ctx) {
    const argumentList = ctx.arguments().argumentList();

    if (argumentList === null || argumentList.getChildCount() !== 1) {
      throw new SemanticArgumentCountMismatchError();
    }

    const arg = argumentList.singleExpression()[0];
    const number = this.removeQuotes(this.visit(arg));

    return `int(${number})`;
  }

  /**
   * Removes quotes from string
   *
   * @param {String} str
   * @returns {String}
   */
  removeQuotes(str) {
    let newStr = str;

    if (
      (str.charAt(0) === '"' && str.charAt(str.length - 1) === '"') ||
      (str.charAt(0) === "'" && str.charAt(str.length - 1) === "'")
    ) {
      newStr = str.substr(1, str.length - 2);
    }

    return newStr;
  }
}

module.exports = Visitor;
